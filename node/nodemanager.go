package node

import (
	"fmt"
	"strings"

	"miego/klog"
	"miego/xmap"
)

type KNodeManager struct {
	//
	// ALL nodes
	//
	nodes []*KNode

	// nodeTypeA <> downstreamNodes
	// dataReady(n, data) => lbNode := nodeTopoType[n.Type]
	//
	// XXX: nm.NodeAdd(node, NodeType, DataFormat, DataType)
	// "NodeType*hint" == (NodeA, NodeB, ..., NodeX)
	followMap map[uint64][]*KNode
}

func (nm *KNodeManager) NodeAdd(node *KNode) {
	node.TypeId = NpAdd(node.Type)
	node.nm = nm
	nm.nodes = append(nm.nodes, node)

	s := node.Follows
	if s == "" {
		return
	}

	var iHint, iNode uint64
	for _, m := range strings.Split(s, ";") {
		segs := strings.Split(m, "@")
		h, n := segs[0], segs[1]

		if h == "" || h == "*" {
			iHint = HT_ANY
		} else {
			iHint = NpNum(h)
		}

		if n == "" || n == "*" {
			iNode = NT_ANY
		} else {
			iNode = NpNum(n)
		}

		nm.LinkAfter(node, iNode, iHint)
	}
}

func catchError() {
	if err := recover(); err != nil {
		klog.F("----------")
		klog.E("%s\n", fmt.Sprint(err))
		klog.F("----------")
	}
}

func (nm *KNodeManager) LinkAfter(node *KNode, nodeType uint64, hint uint64) {
	hashkey := uint64(nodeType) * uint64(hint)

	subNodes, ok := nm.followMap[hashkey]
	if !ok {
		subNodes = make([]*KNode, 0)
	}
	subNodes = append(subNodes, node)
	nm.followMap[hashkey] = subNodes
}

func (nm *KNodeManager) startNodes() {
	for _, n := range nm.nodes {
		if n.OnStart != nil {
			n.OnStart(nm, n)
		}
	}
}

// endPipeline: The pipeline at this node and this data.
func (nm *KNodeManager) endPipeline(node *KNode, data []byte, datafmt uint64, hint uint64) {
	// TODO: Save the frame to database.
	// klog.D("TODO: %s.", node.Name)
}

// Create new frame base on @f and send @data to @nodeDst
//
// @f: Parent frame
//
// XXX: Caller MUST ensure the nodeDst.Processor exists.
func (nm *KNodeManager) callNode(caller *KCallFrame, nodeDst *KNode, data []byte, datafmt uint64, hint uint64) {
	// defer catchError()

	// 1: Create a new frame and save the data and node to it
	newframe := NewCallFrame(caller, nodeDst, data, datafmt, hint)

	// 2: Call nodeDst.Processor with new frame
	if nodeDst.Processor != nil {
		data, datafmt, hint = nodeDst.Processor(newframe)
	}

	// 3. Push to next stage.
	nm.sendtoSubs(newframe, nodeDst, data, datafmt, hint)
}

// XXX: Directly send data to node
//
// @caller: current(caller's) call frame
// @nodeDst: node who will process the data
// @data: data generated by node
func (nm *KNodeManager) SendtoNode(caller *KCallFrame, nodeDst *KNode, data []byte, datafmt uint64, hint uint64) {
	go nm.callNode(caller, nodeDst, data, datafmt, hint)
}

func (nm *KNodeManager) getNexts(node *KNode, hint uint64) []*KNode {
	utype := uint64(node.TypeId)
	uhint := uint64(hint)

	var hashkey uint64
	var nexts []*KNode

	//
	// try: a+b a+* *+b *+*
	//

	hashkey = utype * uhint
	if subNodes, ok := nm.followMap[hashkey]; ok {
		nexts = append(nexts, subNodes...)
	}

	hashkey = uint64(NT_ANY) * uhint
	if subNodes, ok := nm.followMap[hashkey]; ok {
		nexts = append(nexts, subNodes...)
	}

	hashkey = utype * uint64(HT_ANY)
	if subNodes, ok := nm.followMap[hashkey]; ok {
		nexts = append(nexts, subNodes...)
	}

	hashkey = uint64(NT_ANY) * uint64(HT_ANY)
	if subNodes, ok := nm.followMap[hashkey]; ok {
		nexts = append(nexts, subNodes...)
	}

	/*
		klog.D("---------------------------------------------")
		klog.D("THIS IS : %s, T:%s, S:%d, IT'S NEXTS ARE:", node.Name, node.Type, uhint)
		for i, n := range nexts {
			if n == node {
				klog.D("- %d: %s (SKIPPED)", i, n.Name)
				continue
			}
			klog.D("- %d: %s", i, n.Name)
		}
	*/

	return nexts
}

// XXX: Send data to down stream node
//
// @caller: current(caller's) call frame
// @nodeDst: node who generate the data
// @data: data generated by node
func (nm *KNodeManager) sendtoSubs(caller *KCallFrame, nodeSrc *KNode, data []byte, datafmt uint64, hint uint64) {
	nextNodes := nm.getNexts(nodeSrc, hint)
	if nextNodes == nil {
		// XXX: end this pipeline
		nm.endPipeline(nodeSrc, data, datafmt, hint)
	}

	for _, nodeNext := range nextNodes {
		if nodeNext.Processor != nil && nodeNext != nodeSrc {
			klog.W("%v => %v", nodeSrc.Name, nodeNext.Name)
			nm.callNode(caller, nodeNext, data, datafmt, hint)
		}
	}
}

func (nm *KNodeManager) Run() {
	NpDump()

	fmtNode := func(n *KNode) xmap.Map {
		return xmap.Make(
			"     Name", n.Name,
			"     Desc", n.Desc,
			"     Type", n.Type,
			"   TypeId", n.TypeId,
			"Processor", n.Processor,
			"  OnStart", n.OnStart,
		)
	}

	for hashkey, arr := range nm.followMap {
		for i, n := range arr {
			m := fmtNode(n)
			klog.Dump(m, klog.Color("33;1", "%d / %d\n", hashkey, i))
		}
	}

	for i, n := range nm.nodes {
		m := fmtNode(n)
		klog.Dump(m, klog.Color("33;1", "NODE %d\n", i))
	}

	//
	// buildTopo the topology
	//
	nm.startNodes()

	for {
		select {}
	}
}

var NodeManager *KNodeManager

func init() {
	NodeManager = new(KNodeManager)
	NodeManager.followMap = make(map[uint64][]*KNode)
}
